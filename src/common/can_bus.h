/**
 * @file can_bus.h
 *
 * @brief This header file was generated by cantools version 41.0.2 Sun Jan 25 22:18:49 2026.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef CAN_BUS_H
#define CAN_BUS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN_BUS_OBC_HEARTBEAT_FRAME_ID (0x01u)
#define CAN_BUS_OBC_MODE_CMD_FRAME_ID (0x02u)
#define CAN_BUS_OBC_EPS_CMD_FRAME_ID (0x03u)
#define CAN_BUS_OBC_ADCS_CMD_FRAME_ID (0x04u)
#define CAN_BUS_EPS_HEARTBEAT_FRAME_ID (0x100u)
#define CAN_BUS_EPS_STATUS_FRAME_ID (0x101u)
#define CAN_BUS_ADCS_HEARTBEAT_FRAME_ID (0x200u)
#define CAN_BUS_ADCS_MOTOR_CMD_FRAME_ID (0x201u)
#define CAN_BUS_ADCS_MOTOR_STATUS_FRAME_ID (0x202u)
#define CAN_BUS_ADCS_ATT_EST_FRAME_ID (0x301u)
#define CAN_BUS_ADCS_IMU_ACCEL_FRAME_ID (0x302u)
#define CAN_BUS_ADCS_IMU_GYRO_FRAME_ID (0x303u)

/* Frame lengths in bytes. */
#define CAN_BUS_OBC_HEARTBEAT_LENGTH (6u)
#define CAN_BUS_OBC_MODE_CMD_LENGTH (1u)
#define CAN_BUS_OBC_EPS_CMD_LENGTH (1u)
#define CAN_BUS_OBC_ADCS_CMD_LENGTH (1u)
#define CAN_BUS_EPS_HEARTBEAT_LENGTH (5u)
#define CAN_BUS_EPS_STATUS_LENGTH (8u)
#define CAN_BUS_ADCS_HEARTBEAT_LENGTH (6u)
#define CAN_BUS_ADCS_MOTOR_CMD_LENGTH (3u)
#define CAN_BUS_ADCS_MOTOR_STATUS_LENGTH (5u)
#define CAN_BUS_ADCS_ATT_EST_LENGTH (6u)
#define CAN_BUS_ADCS_IMU_ACCEL_LENGTH (6u)
#define CAN_BUS_ADCS_IMU_GYRO_LENGTH (6u)

/* Extended or standard frame types. */
#define CAN_BUS_OBC_HEARTBEAT_IS_EXTENDED (0)
#define CAN_BUS_OBC_MODE_CMD_IS_EXTENDED (0)
#define CAN_BUS_OBC_EPS_CMD_IS_EXTENDED (0)
#define CAN_BUS_OBC_ADCS_CMD_IS_EXTENDED (0)
#define CAN_BUS_EPS_HEARTBEAT_IS_EXTENDED (0)
#define CAN_BUS_EPS_STATUS_IS_EXTENDED (0)
#define CAN_BUS_ADCS_HEARTBEAT_IS_EXTENDED (0)
#define CAN_BUS_ADCS_MOTOR_CMD_IS_EXTENDED (0)
#define CAN_BUS_ADCS_MOTOR_STATUS_IS_EXTENDED (0)
#define CAN_BUS_ADCS_ATT_EST_IS_EXTENDED (0)
#define CAN_BUS_ADCS_IMU_ACCEL_IS_EXTENDED (0)
#define CAN_BUS_ADCS_IMU_GYRO_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/* Frame Names. */
#define CAN_BUS_OBC_HEARTBEAT_NAME "OBC_Heartbeat"
#define CAN_BUS_OBC_MODE_CMD_NAME "OBC_Mode_Cmd"
#define CAN_BUS_OBC_EPS_CMD_NAME "OBC_EPS_Cmd"
#define CAN_BUS_OBC_ADCS_CMD_NAME "OBC_ADCS_Cmd"
#define CAN_BUS_EPS_HEARTBEAT_NAME "EPS_Heartbeat"
#define CAN_BUS_EPS_STATUS_NAME "EPS_Status"
#define CAN_BUS_ADCS_HEARTBEAT_NAME "ADCS_Heartbeat"
#define CAN_BUS_ADCS_MOTOR_CMD_NAME "ADCS_Motor_Cmd"
#define CAN_BUS_ADCS_MOTOR_STATUS_NAME "ADCS_Motor_Status"
#define CAN_BUS_ADCS_ATT_EST_NAME "ADCS_Att_Est"
#define CAN_BUS_ADCS_IMU_ACCEL_NAME "ADCS_IMU_Accel"
#define CAN_BUS_ADCS_IMU_GYRO_NAME "ADCS_IMU_Gyro"

/* Signal Names. */
#define CAN_BUS_OBC_HEARTBEAT_UPTIME_MS_NAME "uptime_ms"
#define CAN_BUS_OBC_HEARTBEAT_MODE_NAME "mode"
#define CAN_BUS_OBC_HEARTBEAT_ERROR_FLAGS_NAME "error_flags"
#define CAN_BUS_OBC_MODE_CMD_MODE_NAME "mode"
#define CAN_BUS_OBC_EPS_CMD_COMMAND_NAME "command"
#define CAN_BUS_OBC_ADCS_CMD_COMMAND_NAME "command"
#define CAN_BUS_EPS_HEARTBEAT_UPTIME_MS_NAME "uptime_ms"
#define CAN_BUS_EPS_HEARTBEAT_ERROR_FLAGS_NAME "error_flags"
#define CAN_BUS_EPS_STATUS_BUS_VOLTAGE_NAME "bus_voltage"
#define CAN_BUS_EPS_STATUS_BUS_CURRENT_NAME "bus_current"
#define CAN_BUS_EPS_STATUS_POWER_NAME "power"
#define CAN_BUS_EPS_STATUS_LOAD_STATUS_NAME "load_status"
#define CAN_BUS_ADCS_HEARTBEAT_UPTIME_MS_NAME "uptime_ms"
#define CAN_BUS_ADCS_HEARTBEAT_MODE_NAME "mode"
#define CAN_BUS_ADCS_HEARTBEAT_ERROR_FLAGS_NAME "error_flags"
#define CAN_BUS_ADCS_MOTOR_CMD_DUTY_CYCLE_NAME "duty_cycle"
#define CAN_BUS_ADCS_MOTOR_CMD_ENABLE_NAME "enable"
#define CAN_BUS_ADCS_MOTOR_STATUS_RPM_NAME "rpm"
#define CAN_BUS_ADCS_MOTOR_STATUS_CURRENT_NAME "current"
#define CAN_BUS_ADCS_MOTOR_STATUS_FAULT_NAME "fault"
#define CAN_BUS_ADCS_ATT_EST_ROLL_NAME "roll"
#define CAN_BUS_ADCS_ATT_EST_PITCH_NAME "pitch"
#define CAN_BUS_ADCS_ATT_EST_YAW_NAME "yaw"
#define CAN_BUS_ADCS_IMU_ACCEL_ACCEL_X_NAME "accel_x"
#define CAN_BUS_ADCS_IMU_ACCEL_ACCEL_Y_NAME "accel_y"
#define CAN_BUS_ADCS_IMU_ACCEL_ACCEL_Z_NAME "accel_z"
#define CAN_BUS_ADCS_IMU_GYRO_GYRO_X_NAME "gyro_x"
#define CAN_BUS_ADCS_IMU_GYRO_GYRO_Y_NAME "gyro_y"
#define CAN_BUS_ADCS_IMU_GYRO_GYRO_Z_NAME "gyro_z"

/**
 * Signals in message OBC_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_obc_heartbeat_t {
    /**
     * Range: 0..4294967295 (0..4294967295 ms)
     * Scale: 1
     * Offset: 0
     */
    uint32_t uptime_ms;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_flags;
};

/**
 * Signals in message OBC_Mode_Cmd.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_obc_mode_cmd_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;
};

/**
 * Signals in message OBC_EPS_Cmd.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_obc_eps_cmd_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t command;
};

/**
 * Signals in message OBC_ADCS_Cmd.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_obc_adcs_cmd_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t command;
};

/**
 * Signals in message EPS_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_eps_heartbeat_t {
    /**
     * Range: 0..4294967295 (0..4294967295 ms)
     * Scale: 1
     * Offset: 0
     */
    uint32_t uptime_ms;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_flags;
};

/**
 * Signals in message EPS_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_eps_status_t {
    /**
     * Range: 0..65535 (0..655.35 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t bus_voltage;

    /**
     * Range: 0..65535 (0..655.35 A)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t bus_current;

    /**
     * Range: 0..65535 (0..6553.5 W)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t power;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t load_status;
};

/**
 * Signals in message ADCS_Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_adcs_heartbeat_t {
    /**
     * Range: 0..4294967295 (0..4294967295 ms)
     * Scale: 1
     * Offset: 0
     */
    uint32_t uptime_ms;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_flags;
};

/**
 * Signals in message ADCS_Motor_Cmd.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_adcs_motor_cmd_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t duty_cycle;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable;
};

/**
 * Signals in message ADCS_Motor_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_adcs_motor_status_t {
    /**
     * Range: 0..65535 (0..65535 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rpm;

    /**
     * Range: 0..65535 (0..655.35 A)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t current;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fault;
};

/**
 * Signals in message ADCS_Att_Est.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_adcs_att_est_t {
    /**
     * Range: -32768..32767 (-3276.8..3276.7 deg/s)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t roll;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 deg/s)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 deg/s)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t yaw;
};

/**
 * Signals in message ADCS_IMU_Accel.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_adcs_imu_accel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m/s2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m/s2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m/s2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_z;
};

/**
 * Signals in message ADCS_IMU_Gyro.
 *
 * All signal values are as on the CAN bus.
 */
struct can_bus_adcs_imu_gyro_t {
    /**
     * Range: -32768..32767 (-3276.8..3276.7 deg/s)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t gyro_x;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 deg/s)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t gyro_y;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 deg/s)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t gyro_z;
};

/**
 * Pack message OBC_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_obc_heartbeat_pack(
    uint8_t *dst_p,
    const struct can_bus_obc_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message OBC_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_obc_heartbeat_unpack(
    struct can_bus_obc_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from OBC_Heartbeat.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_obc_heartbeat_init(struct can_bus_obc_heartbeat_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_bus_obc_heartbeat_uptime_ms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_obc_heartbeat_uptime_ms_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_obc_heartbeat_uptime_ms_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_bus_obc_heartbeat_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_obc_heartbeat_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_obc_heartbeat_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_bus_obc_heartbeat_error_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_obc_heartbeat_error_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_obc_heartbeat_error_flags_is_in_range(uint8_t value);

/**
 * Pack message OBC_Mode_Cmd.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_obc_mode_cmd_pack(
    uint8_t *dst_p,
    const struct can_bus_obc_mode_cmd_t *src_p,
    size_t size);

/**
 * Unpack message OBC_Mode_Cmd.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_obc_mode_cmd_unpack(
    struct can_bus_obc_mode_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from OBC_Mode_Cmd.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_obc_mode_cmd_init(struct can_bus_obc_mode_cmd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_bus_obc_mode_cmd_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_obc_mode_cmd_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_obc_mode_cmd_mode_is_in_range(uint8_t value);

/**
 * Pack message OBC_EPS_Cmd.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_obc_eps_cmd_pack(
    uint8_t *dst_p,
    const struct can_bus_obc_eps_cmd_t *src_p,
    size_t size);

/**
 * Unpack message OBC_EPS_Cmd.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_obc_eps_cmd_unpack(
    struct can_bus_obc_eps_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from OBC_EPS_Cmd.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_obc_eps_cmd_init(struct can_bus_obc_eps_cmd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_bus_obc_eps_cmd_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_obc_eps_cmd_command_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_obc_eps_cmd_command_is_in_range(uint8_t value);

/**
 * Pack message OBC_ADCS_Cmd.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_obc_adcs_cmd_pack(
    uint8_t *dst_p,
    const struct can_bus_obc_adcs_cmd_t *src_p,
    size_t size);

/**
 * Unpack message OBC_ADCS_Cmd.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_obc_adcs_cmd_unpack(
    struct can_bus_obc_adcs_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from OBC_ADCS_Cmd.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_obc_adcs_cmd_init(struct can_bus_obc_adcs_cmd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_bus_obc_adcs_cmd_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_obc_adcs_cmd_command_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_obc_adcs_cmd_command_is_in_range(uint8_t value);

/**
 * Pack message EPS_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_eps_heartbeat_pack(
    uint8_t *dst_p,
    const struct can_bus_eps_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message EPS_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_eps_heartbeat_unpack(
    struct can_bus_eps_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EPS_Heartbeat.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_eps_heartbeat_init(struct can_bus_eps_heartbeat_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_bus_eps_heartbeat_uptime_ms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_eps_heartbeat_uptime_ms_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_eps_heartbeat_uptime_ms_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_bus_eps_heartbeat_error_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_eps_heartbeat_error_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_eps_heartbeat_error_flags_is_in_range(uint8_t value);

/**
 * Pack message EPS_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_eps_status_pack(
    uint8_t *dst_p,
    const struct can_bus_eps_status_t *src_p,
    size_t size);

/**
 * Unpack message EPS_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_eps_status_unpack(
    struct can_bus_eps_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EPS_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_eps_status_init(struct can_bus_eps_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_bus_eps_status_bus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_eps_status_bus_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_eps_status_bus_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_bus_eps_status_bus_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_eps_status_bus_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_eps_status_bus_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_bus_eps_status_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_eps_status_power_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_eps_status_power_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_bus_eps_status_load_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_eps_status_load_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_eps_status_load_status_is_in_range(uint8_t value);

/**
 * Pack message ADCS_Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_adcs_heartbeat_pack(
    uint8_t *dst_p,
    const struct can_bus_adcs_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message ADCS_Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_adcs_heartbeat_unpack(
    struct can_bus_adcs_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADCS_Heartbeat.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_adcs_heartbeat_init(struct can_bus_adcs_heartbeat_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_bus_adcs_heartbeat_uptime_ms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_heartbeat_uptime_ms_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_heartbeat_uptime_ms_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_bus_adcs_heartbeat_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_heartbeat_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_heartbeat_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_bus_adcs_heartbeat_error_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_heartbeat_error_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_heartbeat_error_flags_is_in_range(uint8_t value);

/**
 * Pack message ADCS_Motor_Cmd.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_adcs_motor_cmd_pack(
    uint8_t *dst_p,
    const struct can_bus_adcs_motor_cmd_t *src_p,
    size_t size);

/**
 * Unpack message ADCS_Motor_Cmd.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_adcs_motor_cmd_unpack(
    struct can_bus_adcs_motor_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADCS_Motor_Cmd.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_adcs_motor_cmd_init(struct can_bus_adcs_motor_cmd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_bus_adcs_motor_cmd_duty_cycle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_motor_cmd_duty_cycle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_motor_cmd_duty_cycle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_bus_adcs_motor_cmd_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_motor_cmd_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_motor_cmd_enable_is_in_range(uint8_t value);

/**
 * Pack message ADCS_Motor_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_adcs_motor_status_pack(
    uint8_t *dst_p,
    const struct can_bus_adcs_motor_status_t *src_p,
    size_t size);

/**
 * Unpack message ADCS_Motor_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_adcs_motor_status_unpack(
    struct can_bus_adcs_motor_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADCS_Motor_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_adcs_motor_status_init(struct can_bus_adcs_motor_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_bus_adcs_motor_status_rpm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_motor_status_rpm_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_motor_status_rpm_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_bus_adcs_motor_status_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_motor_status_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_motor_status_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_bus_adcs_motor_status_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_motor_status_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_motor_status_fault_is_in_range(uint8_t value);

/**
 * Pack message ADCS_Att_Est.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_adcs_att_est_pack(
    uint8_t *dst_p,
    const struct can_bus_adcs_att_est_t *src_p,
    size_t size);

/**
 * Unpack message ADCS_Att_Est.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_adcs_att_est_unpack(
    struct can_bus_adcs_att_est_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADCS_Att_Est.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_adcs_att_est_init(struct can_bus_adcs_att_est_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_bus_adcs_att_est_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_att_est_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_att_est_roll_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_bus_adcs_att_est_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_att_est_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_att_est_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_bus_adcs_att_est_yaw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_att_est_yaw_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_att_est_yaw_is_in_range(int16_t value);

/**
 * Pack message ADCS_IMU_Accel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_adcs_imu_accel_pack(
    uint8_t *dst_p,
    const struct can_bus_adcs_imu_accel_t *src_p,
    size_t size);

/**
 * Unpack message ADCS_IMU_Accel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_adcs_imu_accel_unpack(
    struct can_bus_adcs_imu_accel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADCS_IMU_Accel.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_adcs_imu_accel_init(struct can_bus_adcs_imu_accel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_bus_adcs_imu_accel_accel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_imu_accel_accel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_imu_accel_accel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_bus_adcs_imu_accel_accel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_imu_accel_accel_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_imu_accel_accel_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_bus_adcs_imu_accel_accel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_imu_accel_accel_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_imu_accel_accel_z_is_in_range(int16_t value);

/**
 * Pack message ADCS_IMU_Gyro.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_bus_adcs_imu_gyro_pack(
    uint8_t *dst_p,
    const struct can_bus_adcs_imu_gyro_t *src_p,
    size_t size);

/**
 * Unpack message ADCS_IMU_Gyro.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_bus_adcs_imu_gyro_unpack(
    struct can_bus_adcs_imu_gyro_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADCS_IMU_Gyro.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_bus_adcs_imu_gyro_init(struct can_bus_adcs_imu_gyro_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_bus_adcs_imu_gyro_gyro_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_imu_gyro_gyro_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_imu_gyro_gyro_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_bus_adcs_imu_gyro_gyro_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_imu_gyro_gyro_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_imu_gyro_gyro_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_bus_adcs_imu_gyro_gyro_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_bus_adcs_imu_gyro_gyro_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_bus_adcs_imu_gyro_gyro_z_is_in_range(int16_t value);


#ifdef __cplusplus
}
#endif

#endif
